<html>
<head>

<title>Usage of buffer at input transfer</title>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<link rel=StyleSheet href=default.css>
</head>
<body>


<a name=TOPIC_TOP>

<h1>Usage of buffer at input transfer</h1>
<p>
The usage methods of the buffer and functions in a typical pattern for carrying out input transfer (sampling) are described in this section.<br>
<br>
<br>
<h2>Pattern 1: Acquisition of limited data numbers and post-sampling data</h2>
<p>
Single transfer is carried out, and data is acquired after sampling is complete.<br>
<pre><img src="syori.png" border="0" alt="syori.png(440 byte)" width="223" height="43">
              Process</pre>

In this case, a buffer size the same as the required data number size or larger must be prepared.<br>
Specify DIODM_WRITE_ONCE as the buffer repeat specification.<br>
If data input number has been decided, specify the stop condition as DIODM_STOP_NUM, <br>
and try to complete transfer in the number specified by the DioDmSetStopNum function.<br>
<br>
After a transfer is started, wait for the completion message, <br>
or wait in a loop until the status bit DIODM_STATUS_STOP is 
set by the status acquisition function while inserting a wait such as nanosleep.<br>
<br>
<br>
<h2>Pattern 2: Acquisition while sampling limited data numbers and data</h2>
<br>
Single transfer is carried out, and data is acquired during sampling and used.<br>
<pre><img src="syori.png" border="0" alt="syori.png(440 byte)" width="223" height="43">
Process Process Process</pre>

In this case, a buffer size the same as the required data number size or larger must be prepared.<br>
Specify DIODM_WRITE_ONCE as the buffer repeat specification.<br>
If data input number has been decided, specify the stop condition as DIODM_STOP_NUM,<br>
and try to complete transfer in the number specified by the DioDmSetStopNum function.<br>
<br>
The process is carried out while confirming the position that the data is stored<br>
at using the transfer number acquisition function (DioDmGetCount).<br>
<br>
The process should be carried out while checking that erroneous endings<br>
are not generated by the status function in the middle of processing.<br>
Insert a wait such as nanosleep during looping to avoid overloading the system.<br>
<br>
<br>
<h2>Pattern 3: Acquisition of limited data numbers and all data</h2>
<br>
Unlimited transfers are carried out, and when the prescribed amount of data is acquired, processing,<br>
i.e. storing data into the file, is carried out.<br>
<pre><img src="syori.png" border="0" alt="syori.png(440 byte)" width="223" height="43">
Process Process Process</pre>

The transfer number is confirmed by the system timer, etc.,<br>
using the specification number transfer completion message or transfer number acquisition function.<br>
Applications are periodically processed from the read pointer to<br>
the write pointer by the system timer or event message.<br>
<br>
In this case, the read pointer indicating where data is processed up to <br>
and the write pointer indicating up to which part of the buffer data has been written<br>
must be controlled by a user program.<br>
<br>
The read/write pointers are counters that loop back and return to 0 when transfers are carried out up to the buffer size.<br>
The write pointer is requested by using (DioDmGetWritePointerUserBuf).<br>
The read pointer is a write pointer at the last time data processing.<br>
<br>
<br>
<h2>Pattern 4: A random data number from a random part by acquiring unlimited data numbers and write pointers</h2>
<br>
Unlimited transfers are carried out, and when the random conditions are met, random data numbers are acquired from the random part.<br>
In this case, read and write pointers must be controlled as well. <br>
Please refer to pattern 3.<br>
<p>
</BODY>
</HTML>
